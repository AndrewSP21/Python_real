"""1)	Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
который должен принимать данные (список списков) для формирования матрицы. Подсказка: матрица — система некоторых
математических величин, расположенных в виде прямоугольной схемы. Примеры матриц: 3 на 2, 3 на 3, 2 на 4.

31	22
37	43
51	86

3	5	32
2	4	6
-1	64	-8

3	5	8	3
8	3	7	1


Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде. Далее реализовать
перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом
сложения должна быть новая матрица. Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент
первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

"""


class My_list:

    def __init__(self, *args):
        self.list1 = []
        self.list1 += args

    def __str__(self):
        '''
        Список списков'[ [] , [] ]' превращаем в строковую переменную, которая включает в себя перевод сроки \n
        [(' '.join(map(str, i)) + '\n') for i in self.list1] - взять элемент i(тоже спискок) списка self.list1
        и каждый элемент уже списка i перевести в строку - map(str, i), между ними поставить пробел ' ',
        после окончания элемента списка i вставить переод строки \n
        Таким образом список: [[31, 22], [37, 43], [51, 86, 5]] превращается в матрицу без скобок и запятых:
        31 22
        37 43
        51 86 5
        :return:
        '''
        pr_m = (''.join(map(str, [(' '.join(map(str, i)) + '\n') for i in self.list1])))
        return pr_m

    def add_list(self, *args):
        '''
        Функция добавляет к существующему экземпляру класса новые данные
        :param args:
        :return:
        '''
        self.list1 += args

    def leveler(self, other, elem):
        """
        Функция делает списки одинаковыми по количеству и длине элементов, забивая значениями 'elem' недостающие данные
        :param other: Список списков 2
        :param elem: Значения которыми забиваются списки для выравнивания
        :return: Два списка с одинаковым количеством элементов и одинаковой длиной элементов
        """
        def lev(lis1, lis2, element):
            """
            Функция делает одинаковыми по количеству элементов два списка, в меньший список добавляет значения 'element'
            :param lis1: Список 1
            :param lis2: Список 2
            :param element: Значения которыми забиваются списки для выравнивания
            :return: Два списка имеют одинаковое количество элементов
            """
            diff = abs(len(lis1) - len(lis2))
            if len(lis1) > len(lis2):
                for el in range(diff):
                    lis2.append(element)
            elif len(lis1) < len(lis2):
                for el in range(diff):
                    lis1.append(element)
        # Выравниваем длину списков. К короткому списку добавляем список [elem].
        lev(self.list1, other.list1, [elem])
        # Выравниваем длину элементов списка. Важно чтобы 1-й элемент 1-го списка был одинаковой длины с 1-м элементом
        # 2-го списка. Второй элемент, со вторым. И так далее. Это позволит нам складывать списки поэлементно.
        # В этом случае добаляем просто 'elem', а не '[elem]', т.к. в элементе списка перечислены уже числа,
        # а не другие списки.
        for i, j in zip(self.list1, other.list1):
            lev(i, j, elem)

    # def __getitem__(self, key):
    #     return self.list1[key]

    def __add__(self, other):
        '''
        Складываем экземпляры класса, на выходе получем новый экземпляр класса
        :param other:
        :return:
        '''
        # Первый экземпляр класса делаем такой же длины, как и тот экземпляр класса, с которым хотим его сложить
        self.leveler(other, 0)
        # Второй экземпляр класса делаем такой же длины, как и первый экземпляр класса, с которым хотим его сложить
        other.leveler(self, 0)
        # Инициируем новый экземпляр класса, в который будем записывать результат сложения, пустым списком.
        zz = My_list([])
        for i in range(len(self.list1)):
            yy = [] # Список в которы будем записывать сложение элементов списка
            for j in range(len(self.list1[i])):
                yy.append(self.list1[i][j] + other.list1[i][j])
            zz.add_list(yy) #Добавляем в экземпляр класса новые списки
        del zz.list1[0] #Удаляем из экземпляра класса первый элемент, с помощью которого инициировали экземпляр класса
        return zz


a = My_list([31, 22], [37, 43], [51, 86, 5])
print(f'a = \n{a}')
b = My_list([3, 5, 32], [2, 4, 6], [-1, 64, -8], [8], [4], [567], [79])
c = My_list([3, 5, 8, 3], [8, 3, 7, 1])
d = a + b
gg = d + c
print(f'd = \n{d}')
print(f'gg = \n{gg}')


